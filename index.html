<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GitBlock: Touch Edition</title>
    <style>
        :root {
            --bg: #0d1117;
            --grid-bg: #161b22;
            --border: #30363d;
            --accent: #238636;
            --text: #c9d1d9;
            --powerup: #bc8cff;
        }
        body { 
            background: var(--bg); color: var(--text); 
            font-family: -apple-system, sans-serif; 
            display: flex; flex-direction: column; align-items: center; 
            justify-content: center; height: 100vh; margin: 0; overflow: hidden;
            touch-action: none; /* Prevents scrolling while playing */
        }
        #game-container { display: flex; flex-direction: column; align-items: center; gap: 10px; }
        .stats { display: flex; gap: 20px; font-size: 18px; font-weight: bold; margin-bottom: 5px; }
        
        #grid { 
            display: grid; grid-template-columns: repeat(10, 30px); grid-template-rows: repeat(10, 30px); 
            gap: 2px; background: var(--border); padding: 5px; border-radius: 6px;
        }
        .cell { width: 30px; height: 30px; background: var(--grid-bg); border-radius: 3px; pointer-events: auto; }
        .cell.filled { background: var(--accent); border: 1px solid #2ea043; }
        .cell.hover { background: rgba(255,255,255,0.1); }

        #hand { display: flex; gap: 15px; min-height: 100px; margin-top: 20px; align-items: center; }
        .piece { 
            display: grid; gap: 2px; cursor: grab; padding: 5px; 
            background: rgba(255,255,255,0.05); border-radius: 4px;
            touch-action: none; position: relative;
        }
        .piece-cell { width: 18px; height: 18px; background: var(--accent); border-radius: 2px; pointer-events: none; }
        
        /* The visual element following the finger */
        .dragging-visual {
            position: fixed; pointer-events: none; z-index: 1000; opacity: 0.8; transform: scale(1.2);
        }

        button {
            background: #21262d; color: #58a6ff; border: 1px solid var(--border);
            padding: 10px 20px; border-radius: 6px; cursor: pointer; margin-top: 10px;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <div class="stats">
            <div>Score: <span id="score-val">0</span></div>
            <div style="color: var(--powerup)">Energy: <span id="energy-val">0</span></div>
        </div>

        <div id="grid"></div>
        <div id="hand"></div>
        
        <button onclick="resetGame()">Reset Repository</button>
    </div>

    <script>
        const gridElement = document.getElementById('grid');
        const handElement = document.getElementById('hand');
        const scoreVal = document.getElementById('score-val');
        const energyVal = document.getElementById('energy-val');

        let score = 0, energy = 0, grid = [];
        let activePiece = null;
        let activeShape = null;
        let dragElement = null;

        const shapes = [
            [[0,0], [0,1], [1,0], [1,1]], // Square
            [[0,0], [0,1], [0,2]],         // H-Line
            [[0,0], [1,0], [2,0]],         // V-Line
            [[0,0], [1,0], [1,1]],         // L
            [[0,0]]                        // Dot
        ];

        function resetGame() {
            score = 0; energy = 0;
            grid = Array(10).fill().map(() => Array(10).fill(0));
            updateUI();
            initGridUI();
            spawnPieces();
        }

        function initGridUI() {
            gridElement.innerHTML = '';
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `cell-${r}-${c}`;
                    gridElement.appendChild(cell);
                }
            }
        }

        function spawnPieces() {
            handElement.innerHTML = '';
            for (let i = 0; i < 3; i++) createPieceUI();
        }

        function createPieceUI() {
            const shape = shapes[Math.floor(Math.random() * shapes.length)];
            const piece = document.createElement('div');
            piece.className = 'piece';
            
            const maxR = Math.max(...shape.map(p => p[0]));
            const maxC = Math.max(...shape.map(p => p[1]));
            piece.style.gridTemplateRows = `repeat(${maxR + 1}, 18px)`;
            piece.style.gridTemplateColumns = `repeat(${maxC + 1}, 18px)`;

            shape.forEach(p => {
                const pc = document.createElement('div');
                pc.className = 'piece-cell';
                pc.style.gridRowStart = p[0] + 1; pc.style.gridColumnStart = p[1] + 1;
                piece.appendChild(pc);
            });

            // ADD TOUCH EVENTS
            piece.addEventListener('touchstart', (e) => startDrag(e, shape, piece), {passive: false});
            piece.addEventListener('mousedown', (e) => startDrag(e, shape, piece));
            
            handElement.appendChild(piece);
        }

        function startDrag(e, shape, originalElement) {
            e.preventDefault();
            activeShape = shape;
            activePiece = originalElement;
            
            // Create a clone to follow the finger/mouse
            dragElement = originalElement.cloneNode(true);
            dragElement.classList.add('dragging-visual');
            document.body.appendChild(dragElement);
            
            moveDragElement(e);
        }

        function moveDragElement(e) {
            if (!dragElement) return;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            // Offset so your finger doesn't block the view
            dragElement.style.left = (clientX - 30) + 'px';
            dragElement.style.top = (clientY - 80) + 'px';

            // Clear previous hover effects
            document.querySelectorAll('.cell.hover').forEach(c => c.classList.remove('hover'));

            // Find cell under finger
            const cell = getCellAtPos(clientX, clientY);
            if (cell) {
                const r = parseInt(cell.id.split('-')[1]);
                const c = parseInt(cell.id.split('-')[2]);
                if (canPlace(activeShape, r, c)) {
                    showPreview(activeShape, r, c);
                }
            }
        }

        function endDrag(e) {
            if (!dragElement) return;
            const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
            const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
            
            const cell = getCellAtPos(clientX, clientY);
            if (cell) {
                const r = parseInt(cell.id.split('-')[1]);
                const c = parseInt(cell.id.split('-')[2]);
                if (canPlace(activeShape, r, c)) {
                    placeShape(activeShape, r, c);
                    activePiece.remove();
                    if (handElement.children.length === 0) spawnPieces();
                    checkLines();
                }
            }

            document.body.removeChild(dragElement);
            dragElement = null;
            document.querySelectorAll('.cell.hover').forEach(c => c.classList.remove('hover'));
        }

        // Global listeners for dragging
        window.addEventListener('touchmove', (e) => moveDragElement(e), {passive: false});
        window.addEventListener('mousemove', (e) => moveDragElement(e));
        window.addEventListener('touchend', (e) => endDrag(e));
        window.addEventListener('mouseup', (e) => endDrag(e));

        function getCellAtPos(x, y) {
            const el = document.elementFromPoint(x, y);
            return el && el.classList.contains('cell') ? el : null;
        }

        function canPlace(shape, r, c) {
            return shape.every(([dr, dc]) => {
                const nr = r + dr, nc = c + dc;
                return nr >= 0 && nr < 10 && nc >= 0 && nc < 10 && grid[nr][nc] === 0;
            });
        }

        function placeShape(shape, r, c) {
            shape.forEach(([dr, dc]) => {
                grid[r + dr][c + dc] = 1;
                document.getElementById(`cell-${r+dr}-${c+dc}`).classList.add('filled');
            });
            score += shape.length * 10;
            updateUI();
        }

        function showPreview(shape, r, c) {
            shape.forEach(([dr, dc]) => {
                const cell = document.getElementById(`cell-${r+dr}-${c+dc}`);
                if (cell) cell.classList.add('hover');
            });
        }

        function checkLines() {
            let rows = [], cols = [];
            for (let i = 0; i < 10; i++) {
                if (grid[i].every(v => v === 1)) rows.push(i);
                if (grid.map(r => r[i]).every(v => v === 1)) cols.push(i);
            }

            rows.forEach(r => {
                grid[r] = Array(10).fill(0);
                for (let c = 0; c < 10; c++) document.getElementById(`cell-${r}-${c}`).classList.remove('filled');
            });
            cols.forEach(c => {
                for (let r = 0; r < 10; r++) {
                    grid[r][c] = 0;
                    document.getElementById(`cell-${r}-${c}`).classList.remove('filled');
                }
            });
            if (rows.length > 0 || cols.length > 0) score += (rows.length + cols.length) * 100;
            updateUI();
        }

        function updateUI() {
            scoreVal.innerText = score;
            energyVal.innerText = energy;
        }

        resetGame();
    </script>
</body>
</html>
